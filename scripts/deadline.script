-- TODO: solve for move up and down at the same time (one animation gets cancelled)

local c = require("modules.common")

local consume_down_by, move_down, countdown, continue_countdown

function init(self)
	self.cd = coroutine.create(countdown)
	self.down_by = 0
	timer.delay(1, true, consume_down_by)
end

function consume_down_by(self, handle, time_elapsed)
	if self.down_by > 0 then
		move_down(self.down_by)
		self.down_by = 0
	end
end

function move_down(down_by)
	local new_position_y = go.get_position().y - down_by*c.TILE_SIZE
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD,
		new_position_y, go.EASING_INOUTQUAD, 0.5
	)
end

function countdown(self)
	coroutine.yield(3)
	coroutine.yield(2)
	return 1
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		go.delete(message.other_id)
		msg.post("/main", "block_lost")
		msg.post("/blockspawner#script", "stop_spawning")
		msg.post("/blockspawner#script", "delete_last_block")
		_, time = coroutine.resume(self.cd, self)
		print(time)
		timer.delay(1, true, continue_countdown)
	elseif message_id == hash("move_up") then
		local new_position_y = go.get_position().y + c.DEADLINE_RAISE*c.TILE_SIZE
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD,
			new_position_y, go.EASING_INOUTQUAD, 0.5, 0,
				function(self, url, property)
					msg.post("/main#script", "deadline_moved")
				end)
	elseif message_id == hash("block_removed") then
		self.down_by = self.down_by + 1
	end
end

function continue_countdown(self, handle, time_elapsed)
	local status, time = coroutine.resume(self.cd, self)
	if status then
		print(time)
	else
		msg.post("/main#script", "show_game_over")
		timer.cancel(handle)
	end
end