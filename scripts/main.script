local LEVEL_STEP = 2

local count = 6
local last_level = count
local score = 0
local power = false

local spawn_or_switch, switch_level, set_count, change_score

function init(self)
	math.randomseed(os.time())
	math.random();math.random();math.random();  -- discard first few random numbers
	msg.post(".", "acquire_input_focus")
	msg.post("/guis#gui", "update_score", {score = score})
	msg.post("/guis#gui", "update_count", {count = count})
	msg.post("/basespawner#script", "spawn_base")
	msg.post("/blockspawner#script", "spawn_block")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("block_spawned") then
		set_count(count - 1)
	elseif message_id == hash("block_put") then
		change_score(1)
		msg.post("/blockspawner#script", "pass_spawned_to_put")
		spawn_or_switch()
	elseif message_id == hash("block_lost") then
		change_score(-1)
	elseif message_id == hash("block_saved") then
		change_score(1)
	elseif message_id == hash("game_over") then
		msg.post("main:/loader#script", "end_game")
	elseif message_id == hash("current_block_removed") then
		spawn_or_switch()
	elseif message_id == hash("deadline_moved") then
		power = true
		msg.post("/guis#gui", "enable_power")
		msg.post("/supportspawner#script", "spawn_supports")
		msg.post("/blockspawner#script", "spawn_block")
	end
end

function change_score(value)
	score = score + value
	msg.post("/guis#gui", "update_score", {score = score})
end

function spawn_or_switch()
	if count == 0 then
		switch_level()
	else
		msg.post("/blockspawner#script", "spawn_block")
	end
end

function set_count(value)
	count = value
	msg.post("/guis#gui", "update_count", {count = count})
end

function switch_level()
	set_count(last_level + LEVEL_STEP)
	last_level = count
	msg.post("/deadline#script", "move_up")
end

function on_input(self, action_id, action)
	if action_id == hash("remove") and power then
		power = false
		msg.post("/guis#gui", "disable_power")
		msg.post("/blockspawner", "delete_put_block")
	end
end