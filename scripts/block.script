go.property("state", 0)

local c = require("modules.common")

local SPEED_LOW = 50
local SPEED_HIGH = 120
local Q_90_ABOUT_Z = vmath.quat_axis_angle(vmath.vector3(0, 0, 1), math.pi/2)

local speed = SPEED_LOW
local move, move_and_block, block, unblock, check_fall, touched_enough

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("#dynamicco", "disable")
	self.state = c.STATES.current.still
end

function update(self, dt)
	if c.is_state(self.state, c.STATES.current) then
		move(vmath.vector3(0, -speed*dt, 0))
	end
end

function move(vector)
	go.set_position(go.get_position() + vector)
end

function on_input(self, action_id, action)
	if action_id == hash("left") and c.is_state(self.state, c.STATES.current.still) then
		move_and_block(self, vmath.vector3(-9, 0, 0))
	elseif action_id == hash("right") and c.is_state(self.state, c.STATES.current.still) then
		move_and_block(self, vmath.vector3(9, 0, 0))
	elseif action_id == hash("rotate") and action.pressed then
		go.animate(".", "rotation", go.PLAYBACK_ONCE_FORWARD, go.get_rotation()*Q_90_ABOUT_Z, go.EASING_LINEAR, 0.08)
	elseif action_id == hash("fast") and action.pressed then
		speed = SPEED_HIGH
	elseif action_id == hash("fast") and action.released then
		speed = SPEED_LOW
	end
end

function move_and_block(self, vector)
	move(vector)
	block(self, 0.1)
end

function block(self, secs)
	self.state = c.STATES.current.skidding
	timer.delay(secs, false, unblock)
end

function unblock(self)
	if c.is_state(self.state, c.STATES.current.skidding) then
		self.state = c.STATES.current.still
	end
end

function on_message(self, message_id, message, sender)
	if c.is_state(self.state, c.STATES.current) and touched_enough(message_id, message) then
		self.state = c.STATES.put
		msg.post(".", "release_input_focus")
		msg.post("#kinematicco", "disable")
		msg.post("#dynamicco", "enable")
		msg.post("/main#script", "block_put")
		msg.post("/blockspawner#script", "spawn_block")
		timer.delay(1, true, check_fall)
	elseif c.is_state(self.state, c.STATES.falling) and touched_enough(message_id, message) then
		self.state = c.STATES.put
		msg.post("/main#script", "block_put")
		timer.delay(1, true, check_fall)
	end
end

function touched_enough(message_id, message)
	return message_id == hash("contact_point_response") and message.distance > 0.5
end

function check_fall(self, handle, time_elapsed)
	if vmath.length_sqr(go.get("#dynamicco", "linear_velocity")) > 400 then
		self.state = c.STATES.falling
		msg.post("/main#script", "block_lost")
		timer.cancel(handle)
	end
end